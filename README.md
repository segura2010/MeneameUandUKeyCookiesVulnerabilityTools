# Menéame U&UKey Cookies Vulnerability Tools

Esta vulnerabilidad permite a un usuario malicioso crear cookies válidas para cualquier usuario de Menéame (o algún clon, sobretodo en clones).

En todo el código se hace uso de una variable llamada `current_user`, que se corresponde con un objeto de tipo `User` y que se gestiona crea como podemos ver en [1]. Para crear ese usuario, se lo primero que se comprueba es si están presentes las cookies "u" y "ukey". 

```
if(!isset($globals['no_auth']) &&
	isset($_COOKIE['ukey']) &&
	isset($_COOKIE['u']) &&
	($this->u = explode(":", $_COOKIE['u'])) &&
	$this->u[0] > 0
)
```


Estás cookies son de la forma:

```
"u": 2909:2909:1482513506:bd7a2c84

"ukey": MjkwOTowZDFkN2QzMmYxZTg4ODRiYTc3ZmM4MDY1NjU1OWE3Njo3OjE0ODI1MDg1NTc6MA==

DecodeBase64(ukey) = 2909:0d1d7d32f1e8884ba77fc80656559a76:7:1482508557:0
```

siendo:

```
u = "idusuario:idusuario:timestamp:firma"; donde

firma = substr(md5("idusuario:idusuario:timestamp".$site_key), 0, 8);


ukey = base64_encode(
						$this->user_id.':'
						.md5($site_key.$this->user_login.$this->user_id.$this->pass_frag.$globals['now']).':'
						.self::CURRENT_VERSION.':' // Version number
						.$globals['now'].':' // es un timestamp
						.$time // tiempo de expiracion de la cookie, normalmente = 0
);
```

Como veiamos en la condición "if", se hace un "explode" de las cookies, de forma que nos quede un array de elementos basados en los separadores ":".

Si avanzamos en el código vemos que:

```
$userInfo=explode(":", base64_decode($_COOKIE['ukey']));
if($this->u[0] == $userInfo[0]) {
...
}
```

Lo importante es que las cookies u, y ukey, coincidan en su primer elemento, es decir, en ambas el identificador de usuario debe ser el mismo.

Con eso se ejecutará el código necesario para recuperar el usuario de la BD y preparar una firma, con la que se comprobará si la cookie realmente pertenece a ese usuario. Dicha firma se calcula en el siguiente fragmento de código:

```
$user=$db->get_row("SELECT SQL_CACHE user_id, user_login, substring(user_pass, 8, 10) as pass_frag, user_level, UNIX_TIMESTAMP(user_validated_date) as user_date, user_karma, user_email, user_avatar, user_comment_pref FROM users WHERE user_id = $user_id");
if ($this->version == self::CURRENT_VERSION) {
	$key = md5($site_key.$user->user_login.$user->user_id.$user->pass_frag.$cookietime);
} else  {
	$key = md5($user->user_email.$site_key.$user->user_login.$user->user_id.$cookietime);
}
```

Si nos fijamos, hay dos opciones para comprobar la firma:

- Que la versión indicada en ukey sea la misma que la versión actual de la plataforma (en este momento es la versión 7)
	- En este caso, se utiliza parte del hash de la contraseña del usuario (solamente 3 carácteres, lo que hace ligeramente posible un ataque de fuerza bruta)
- Que la versión indicada sea distinta.
	- En este caso, no se usa la contraseña, se utiliza información del usuario que un atacante puede conocer de forma relativamente sencilla:
		- $user->user_email: email del usuario
		- $user->user_login: nombre de usuario
		- $user->user_id
		- $cookietime: tiempo de creacion de la cookie? (no importa el valor)
		- $site_key: clave del sitio (único valor que no conocemos).


Una vez generada esta firma, se comprueba si coincide con el segundo elemento de "ukey". Si son igual, la cookie es correcta.

La idea del ataque es generar una cookie "ukey" válida a partir de los datos que tenemos, pero nos falta el $site_key.

### Romper $site_key
- **Opción 1.**
	- Registrando un usuario y mirando nuestras cookies podemos conocer cual es la firma que se incluye en la cookie "u".
	- Fuerza bruta para saber cual es el valor de $site_key (en local, solamente necesitamos capacidad de computo). Generar firmas hasta que coincida.
	- $site\_key, por el código, debería ser numero entero (relativamente grande, $site_key=12345679 por defecto) (Ver [2]).
	- **Opción no recomendada**. Se utilizan los primeros 8 carácteres del hash md5, por lo que el riesgo de colisión aumenta.
- **Opción 2.**
	- Como podemos ver en [3], se genera una "key" para el formulario de edición de un comentario. Podemos utilizar un comentario aleatorio del sistema y acceder a la url: http://host/backend/comment_ajax.php?id=IDCOMENTARIO. Utilizamos "randkey" para calcular un hash que coincida con el del campo "key" (`key=md5(randkey+site_key)`)
- **Opción 3.**
	- Usar directamente la cookie "ukey" del usuario de pruebas registrado para obtener $site_key por fuerza bruta.


En la mayoría de los clones de Menéame, debido probablemente a la falta de documentación sobre esta variable, el site_key será el valor por defecto. En Menéame no es el valor por defecto, por lo que se debe realizar una ataque por fuerza bruta para tratar de obtenerlo. En teoría, debería ser un número entero, y en función del sistema podría ser como máximo:

- 2147483647 si el sistema es de 32 bits (máximo número entero representable). Por tanto el rango de posibles valores podría ser: [-2147483647, 2147483647]
- 9223372036854775807 si el sistema es de 64 bits (máximo número entero representable). Por tanto el rango de posibles valores podría ser: [-9223372036854775807, 9223372036854775807].

Sabiendo esto, teóricamente deberíamos poder romper la clave y generar cookies válidas para cualquier usuario (siempre que conozcamos su email).

Una vez tengamos el email y el site_key, solamente es necesario generar la cookie indicando en la versión de Menéame una versión (tercer valor) diferente a la que se este ejecutando (por ejemplo: 6)

Si el atacante no conoce su email, es posible realizar un ataque por fuerza bruta al hash de la contraseña, ya que se utilizan solamente 3 carácteres. Tardaría más, pero teóricamente es posible.


### Posibles soluciones

- Eliminar la posibilidad de aceptar cookies basadas en el email, eliminando el "else" correspondiente al chequeo de versión de la cookie.
- Hacer que $site_key sea una cadena de carácteres, lo que permite que se incluyan letras, números y carácteres especiales. De esta forma se hace más fuerte la clave.
- Mayor documentación sobre la variable $site_key, de forma que otros proyectos que usen el código fuente de menéame sepan de la importancia de esta variable y de utilizar un valor diferente al valor por defecto.


### Software

En este repositorio puede encontrar:

- **BruteForcer_SiteKey**: simple programa en C++ para romper el site\_key. Hace uso de OpenMP para paralelizar el proceso y hacer más rápido (por randkey del comentario o por user id).
- **CookieGenerator**: script Python para generar las cookie "u" y "ukey" una vez conozcamos el site\_key y el resto de información necesaria.

**Referencias**:

1: https://github.com/gallir/Meneame/blob/master/www/libs/login.php#L57

2: https://github.com/gallir/Meneame/blob/master/www/config.php#L395

3: https://github.com/gallir/Meneame/blob/7d1f4cdb1b07b5572aeaa8a8c299362fe852d1dc/www/backend/comment_ajax.php#L71